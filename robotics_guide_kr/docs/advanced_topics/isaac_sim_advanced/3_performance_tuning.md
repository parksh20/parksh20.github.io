# Isaac Sim 고급 토픽: 성능 튜닝 및 최적화

Isaac Sim은 매우 사실적이고 복잡한 로봇 시뮬레이션을 가능하게 하지만, 때로는 대규모 씬이나 복잡한 물리 상호작용으로 인해 성능 문제가 발생할 수 있습니다. 시뮬레이션의 실시간성을 유지하고 개발 효율성을 높이기 위해서는 성능 튜닝 및 최적화 기법을 이해하고 적용하는 것이 중요합니다.

이 섹션에서는 대규모 씬 작업 시의 모범 사례, 성능 병목 현상 디버깅 방법, 그리고 시뮬레이션 설정을 최적화하여 Isaac Sim의 성능을 최대한 활용하는 전략에 대해 논의합니다.

## 1. 대규모 씬(Scene) 작업을 위한 모범 사례

복잡하고 많은 에셋을 포함하는 대규모 씬을 다룰 때는 다음과 같은 모범 사례를 따르는 것이 성능 유지에 도움이 됩니다.

*   **USD 페이로드(Payloads) 및 참조(References) 적극 활용:**
    *   **페이로드:** 씬을 구성하는 복잡한 에셋(예: 로봇, 대형 환경)은 페이로드로 로드하는 것이 좋습니다. 페이로드는 씬을 열 때 해당 에셋을 실제로 로드할지 여부를 선택적으로 제어할 수 있게 해줍니다. 사용자는 현재 작업에 필요한 부분만 로드하여 씬 로딩 시간과 메모리 사용량을 줄일 수 있습니다.
        *   예: `stage.DefinePrim("/World/MyComplexRobot", "Xform")` 후, 해당 프림에 페이로드 추가.
    *   **참조:** 반복적으로 사용되는 에셋(예: 동일한 종류의 나무, 볼트)은 외부 USD 파일로 저장하고, 씬에서는 이 파일을 참조(Reference) 형태로 가져옵니다. 이렇게 하면 원본 에셋 파일 하나만 관리하면 되므로 데이터 관리가 용이하고, 인스턴싱(아래 참조)과 함께 사용될 경우 성능 이점을 얻을 수 있습니다.
*   **인스턴싱(Instancing) 사용:**
    *   씬 내에 동일한 에셋이 여러 번 반복해서 나타나는 경우(예: 많은 나사, 동일한 모델의 컨베이어 벨트 여러 개), 각 에셋을 개별적으로 로드하는 대신 인스턴싱을 사용합니다.
    *   인스턴싱된 에셋은 메모리에 한 번만 로드되고 여러 위치에 효율적으로 렌더링되므로, 메모리 사용량과 렌더링 시간을 크게 줄일 수 있습니다.
    *   USD에서 프림에 `instanceable = true` 메타데이터를 설정하고, 이 프림을 여러 위치에 복사(참조 형태로)하면 인스턴싱이 적용됩니다.
*   **가시성 컬링(Visibility Culling) 및 LOD(Level of Detail) 활용:**
    *   **가시성 컬링:** 카메라 시야각(frustum) 밖에 있거나 다른 물체에 의해 완전히 가려진(occluded) 에셋은 렌더링하지 않도록 하여 렌더링 부하를 줄입니다. Isaac Sim의 렌더러는 기본적으로 이러한 기능을 수행하지만, 에셋의 경계 상자(bounding box)를 정확하게 설정하는 것이 도움이 될 수 있습니다.
    *   **LOD (Level of Detail):** 카메라로부터의 거리에 따라 에셋의 복잡도(폴리곤 수, 텍스처 해상도)를 다르게 표시하는 기법입니다. 멀리 있는 물체는 단순한 모델로, 가까이 있는 물체는 상세한 모델로 표시하여 전체적인 렌더링 성능을 향상시킵니다. LOD를 지원하는 에셋을 사용하거나 직접 제작해야 합니다. USD는 Variant Sets를 통해 LOD를 효과적으로 관리할 수 있습니다.
*   **씬 계층 구조 최적화:**
    *   너무 깊거나 복잡한 프림 계층 구조는 씬 탐색 및 업데이트 성능을 저하시킬 수 있습니다. 논리적인 그룹화를 유지하되, 불필요하게 깊은 계층은 피하는 것이 좋습니다.
    *   관련 없는 많은 수의 프림을 하나의 부모 아래에 두기보다는, 의미 있는 단위로 그룹화하여 관리합니다.
*   **불필요한 데이터 제거 및 압축:**
    *   사용하지 않는 프림, 속성, 재질 등은 씬에서 제거합니다.
    *   텍스처 파일은 적절한 해상도로 사용하고, 가능한 경우 압축된 형식을 사용합니다. (예: DDS)
*   **시뮬레이션 메시와 렌더링 메시 분리:**
    *   물리 시뮬레이션에 사용되는 충돌 메시(collision mesh)는 가능한 한 단순한 형태(예: Convex Hull, 기본 도형 조합)로 만들고, 시각적으로 보이는 렌더링 메시(rendering mesh)는 더 복잡하게 만들 수 있습니다. 이렇게 하면 물리 계산 부하를 줄이면서도 시각적 품질을 유지할 수 있습니다.
*   **효율적인 머티리얼 사용:**
    *   과도하게 복잡한 머티리얼 그래프나 고해상도 텍스처의 무분별한 사용은 렌더링 성능에 부담을 줄 수 있습니다. 필요한 수준의 디테일과 성능 사이의 균형을 맞춥니다.
    *   MDL(Material Definition Language)을 사용하여 재사용 가능하고 최적화된 머티리얼을 만듭니다.

## 2. 성능 병목 현상 디버깅

시뮬레이션이 느려지거나 프레임 속도가 떨어질 때, 원인이 되는 병목 현상을 찾아 해결해야 합니다. Isaac Sim 및 Omniverse는 다음과 같은 도구와 기법을 제공합니다.

*   **프로파일러 (Profiler):**
    *   Omniverse Kit에 내장된 프로파일러는 CPU 및 GPU 작업의 실행 시간, 호출 빈도 등을 상세하게 분석하여 어떤 부분이 성능 병목을 일으키는지 식별하는 데 매우 유용합니다.
    *   **접근 방법:** 일반적으로 **Window > Analysis > Profiler** 메뉴를 통해 열 수 있습니다.
    *   **사용 방법:**
        1.  프로파일러 창에서 "Start Capture" (또는 유사한 버튼)를 눌러 데이터 수집을 시작합니다.
        2.  시뮬레이션을 잠시 실행하거나 성능 저하가 발생하는 특정 작업을 수행합니다.
        3.  "Stop Capture"를 누르고 수집된 데이터를 분석합니다.
        4.  CPU 시간, GPU 시간, 각 함수/작업별 소요 시간 등을 확인하여 가장 많은 시간을 소비하는 부분을 찾습니다.
        5.  예를 들어, 특정 Python 스크립트, OmniGraph 노드, 물리 계산, 또는 렌더링 관련 작업이 병목일 수 있습니다.
*   **GPU 프로파일러 (예: NVIDIA Nsight Graphics):**
    *   렌더링 관련 병목이 의심될 경우, NVIDIA Nsight Graphics와 같은 외부 GPU 프로파일링 도구를 사용하여 GPU 작업을 더 심층적으로 분석할 수 있습니다. 렌더링 호출, 셰이더 실행, GPU 메모리 사용량 등을 자세히 볼 수 있습니다.
*   **통계 오버레이 (Statistics Overlay):**
    *   뷰포트에 현재 프레임 속도(FPS), 렌더링 시간, 물리 계산 시간, 오브젝트 수 등의 실시간 통계를 표시하는 기능입니다.
    *   **접근 방법:** 일반적으로 뷰포트 설정이나 디버그 메뉴에서 활성화할 수 있습니다. (예: **Window > Simulation > Info** 또는 유사 경로)
    *   이를 통해 시뮬레이션의 특정 변경 사항이 성능에 미치는 영향을 즉각적으로 확인할 수 있습니다.
*   **로그 분석:**
    *   Isaac Sim 콘솔 창이나 로그 파일에 출력되는 경고 또는 오류 메시지를 주의 깊게 살펴봅니다. 때로는 성능 문제와 관련된 힌트를 얻을 수 있습니다.
*   **단계적 비활성화/활성화:**
    *   씬의 특정 부분(예: 복잡한 로봇, 특정 센서, OmniGraph 로직, 특정 렌더링 효과)을 하나씩 비활성화하거나 단순화하면서 성능 변화를 관찰합니다. 이를 통해 문제의 원인이 되는 요소를 좁혀나갈 수 있습니다.
    *   예를 들어, 모든 센서 데이터 발행을 껐을 때 성능이 크게 향상된다면 센서 데이터 처리나 ROS 브리지 부분이 병목일 수 있습니다.

## 3. 시뮬레이션 설정 최적화

Isaac Sim의 시뮬레이션 설정을 조정하여 성능과 정확도 사이의 균형을 맞출 수 있습니다.

*   **물리 시뮬레이션 스텝 (Physics Stepping):**
    *   **Time Steps Per Second (Hz):** 물리 엔진이 초당 몇 번 계산을 수행할지를 결정합니다. 값이 높을수록 시뮬레이션의 정확도가 높아지지만 계산 부하도 커집니다. 일반적인 로봇 시뮬레이션에서는 60Hz 또는 120Hz가 자주 사용됩니다. 실제 로봇의 제어 주기와 맞추거나, 필요한 최소한의 값으로 설정하여 성능을 확보할 수 있습니다.
    *   **Number of Substeps:** 각 물리 스텝 사이를 더 작은 내부 스텝으로 나누어 계산의 안정성을 높입니다. 특히 복잡한 접촉이나 빠른 움직임이 있는 경우 도움이 될 수 있지만, 역시 계산량을 늘립니다.
    *   **설정 위치:** 일반적으로 **Stage 창 > PhysicsScene 프림 선택 > 속성(Property) 패널** 또는 시뮬레이션 설정 메뉴에서 찾을 수 있습니다.
*   **렌더링 옵션 (Rendering Options):**
    *   **렌더 모드 선택:**
        *   **Real-time (RTX Real-Time):** 빠른 속도와 좋은 품질의 균형을 제공합니다. 일반적인 인터랙티브 시뮬레이션에 적합합니다.
        *   **Path Tracing (RTX Path-Traced):** 가장 사실적인 이미지를 생성하지만 계산 비용이 매우 높습니다. 최종 이미지 렌더링이나 고품질 영상 제작에 사용되며, 실시간 시뮬레이션에는 부적합할 수 있습니다.
        *   **Interactive (Good/Fast):** 이전 세대 렌더링 방식으로, RTX 기능이 없는 하드웨어나 빠른 프로토타이핑에 사용될 수 있습니다.
    *   **렌더링 품질 설정:** 해상도, 안티앨리어싱 수준, 그림자 품질, 반사 품질 등 다양한 렌더링 품질 설정을 낮추면 성능을 향상시킬 수 있습니다. (예: **Render Settings** 창)
    *   **불필요한 렌더링 효과 비활성화:** 모션 블러, 심도 효과(Depth of Field) 등 시뮬레이션에 필수적이지 않은 시각 효과를 끄면 성능에 도움이 됩니다.
*   **GPU 메모리 관리:**
    *   **텍스처 스트리밍:** 모든 텍스처를 항상 GPU 메모리에 올려두는 대신, 필요한 텍스처만 스트리밍하여 로드하는 옵션이 있다면 활용합니다.
    *   고해상도 텍스처 사용 최소화 및 텍스처 압축 사용.
*   **병렬 처리 활용 (Multi-threading / GPU Acceleration):**
    *   Isaac Sim은 내부적으로 병렬 처리와 GPU 가속을 최대한 활용하도록 설계되어 있습니다. 하지만 사용자가 작성하는 Python 스크립트나 커스텀 로직이 CPU 바운드(CPU-bound) 작업으로 인해 병목이 되지 않도록 주의해야 합니다.
    *   NumPy, PyTorch 등 GPU 연산을 지원하는 라이브러리를 효과적으로 사용하고, CPU에서 수행되는 무거운 계산은 가능한 최적화하거나 비동기적으로 처리하는 것을 고려합니다.
*   **헤드리스 모드 (Headless Mode) 사용:**
    *   UI 렌더링 없이 백그라운드에서 시뮬레이션만 실행하는 모드입니다. 대규모 RL 학습이나 배치(batch) 시뮬레이션 실행 시 렌더링 오버헤드를 제거하여 계산 속도를 크게 높일 수 있습니다.
    *   Isaac Sim 실행 시 커맨드 라인 옵션 (`--headless`)이나 스크립트 내에서 설정할 수 있습니다.

성능 튜닝은 종종 시행착오를 동반하는 과정입니다. 다양한 설정과 기법을 실험해보고, 프로파일러를 통해 그 효과를 측정하면서 자신의 시뮬레이션 환경에 가장 적합한 최적화 방안을 찾아나가는 것이 중요합니다. 정확한 물리 시뮬레이션, 사실적인 _렌더링, 그리고 실시간 상호작용 사이에서 적절한 균형점을 찾는 것이 목표입니다.
